# -*- coding: utf-8 -*-
"""CVAE.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F6zfX23WDm8L6dTGd7xAgrtKMAzxTxVI
"""

import torch
import torchvision
import matplotlib.pyplot as plt
import torch.nn as nn
import numpy as np
import torch.nn.functional as F

"""# Condotional Variational AutoEncoder"""

class CVAE(nn.Module):
    def __init__(self, input_dim, latent_dim1, latent_dim2, output_dim, encoder_condition, decoder_condition):
        super(VAE, self).__init__()
        self.encoder1 = nn.Linear(input_dim+encoder_condition, latent_dim1)
        self.encoder2 = nn.Linear(latent_dim1, latent_dim2*2)
        self.decoder1 = nn.Linear(latent_dim2+decoder_condition, latent_dim1)
        self.decoder2 = nn.Linear(latent_dim1, output_dim)

    def reparameterize(self, mu, log_var):
        std = torch.exp(0.5*log_var) 
        eps = torch.randn_like(std) 
        sample = mu + (eps * std) 
        return sample
 
    def forward(self, x, c_encoder=None, c_decoder=None):
        if c_encoder is not None:
          x = torch.cat(x, c_encoder)
        x = F.relu(self.encoder1(x))
        x = self.encoder2(x).view(-1, 2, latent_dim2)
        mu = x[:, 0, :]
        log_var = x[:, 1, :]
        z = self.reparameterize(mu, log_var)
        if c_decoder is not None:
          z = torch.cat(z, c_decoder)
        z = F.relu(self.decoder1(z))
        reconstruction = torch.sigmoid(self.decoder2(z))
        return reconstruction, mu, log_var